import os
from SCons.Script import Import
import htmlmin
from jsmin import jsmin
import csscompressor

Import("env")

def minify_html_content(content):
    return htmlmin.minify(content, remove_comments=True, remove_empty_space=True)

def minify_js_content(content):
    return jsmin(content)

def minify_css_content(content):
    return csscompressor.compress(content)

def process_file(file_path):
    extension = os.path.splitext(file_path)[1].lower()
    try:
        with open(file_path, "rb") as file:
            binary_content = file.read()
    except UnicodeDecodeError:
        print(f"Error reading file {file_path}. Assuming binary content.")
        return binary_content

    # Обработка текстового содержимого в зависимости от расширения файла
    try:
        if extension in ['.html', '.htm']:
            return minify_html_content(binary_content.decode('utf-8')).encode('utf-8')
        elif extension in ['.js']:
            return minify_js_content(binary_content.decode('utf-8')).encode('utf-8')
        elif extension in ['.css']:
            return minify_css_content(binary_content.decode('utf-8')).encode('utf-8')
        else:
            return binary_content
    except UnicodeDecodeError:
        print(f"Error decoding file {file_path}. Skipping minimization.")
        return binary_content

def generate_resource_header(input_file, header_file, variable_name):
    with open(input_file, "rb") as file:
        resource_content = file.read()

    hex_content = ', '.join(f'0x{byte:02x}' for byte in resource_content)
    content_length = len(resource_content)

    with open(header_file, "a", encoding="utf-8") as file:
        file.write(f'#ifndef {variable_name}_H\n#define {variable_name}_H\n\n')
        file.write(f'const uint8_t {variable_name}[] PROGMEM = {{{hex_content}}};\n')
        file.write(f'const size_t {variable_name}_len = {content_length};\n\n')
        file.write(f'#endif // {variable_name}_H\n\n')

def process_resources(resource_dir, output_file):
    resources = {
        "index.html": "indexHtml",
        "logo.svg": "logoSvg",
        "favicon.ico": "faviconIco",
        "styles.css": "stylesCss",
        "three.module.min.js": "threeModuleMinJs" ,
        "three.core.min.js": "threeCoreMinJs" 
    }

    os.makedirs(os.path.dirname(output_file), exist_ok=True)

    with open(output_file, "w", encoding="utf-8") as file:
        file.write("// Autogenerated file, do not edit\n")
        file.write("#include <Arduino.h>\n")
        file.write("#include <cstdint>\n\n")

    for resource, var_name in resources.items():
        input_file = os.path.join(resource_dir, resource)
        if os.path.isfile(input_file):
            minified_content = process_file(input_file)
            temp_minified_file = input_file + ".min"
            with open(temp_minified_file, "wb") as file:
                file.write(minified_content)
            generate_resource_header(temp_minified_file, output_file, var_name)
            os.remove(temp_minified_file)
        else:
            print(f"Resource file not found: {input_file}")

def before_build_action(env):
    project_dir = env['PROJECT_DIR']
    resource_dir = os.path.join(project_dir, "html")
    output_file = os.path.join(project_dir, "include", "embedded_resources.h")
    print(f"Embedding resources from {resource_dir} into {output_file}")
    process_resources(resource_dir, output_file)

before_build_action(env)
# env.AddPreAction("buildprog", before_build_action)