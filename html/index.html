<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SENSORIO</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header>
      <img src="logo.svg" alt="Logo" class="logo" />
      <h1>SENSORIO</h1>
    </header>
    <main>
      <button id="streamButton">Start Streaming</button>
    </main>
    <script type="importmap">
      {
        "imports": {
          "three": "/three.module.min.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "/OrbitControls.min.js";

      let isStreaming = false;
      let intervalId;

      // Three.js setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Add OrbitControls for camera rotation
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // Smooth movement
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 5;
      controls.maxDistance = 20;
      controls.target.set(0, 0, 0); // Center of the skeleton

      camera.position.set(0, 0, 10); // Position the camera to see the entire skeleton

      // Описание костей с иерархией через parentBone
      const bonesConfig = [
        {
          id: 0, // ID первой кости
          length: 3.5, // Длина кости
          deviceId: 0, // Номер устройства, привязанного к этой кости
          axisMapping: {
            x: "gx", // Вектор gx устройства проецируется на ось X кости
            y: "gy", // Вектор gy устройства проецируется на ось Y кости
            z: "gz", // Вектор gz устройства проецируется на ось Z кости
          },
          initialPosition: { x: 0, y: 0, z: 0 }, // Начальное положение кости
          color: 0xff0000, // Цвет кости (красный)
          parentBone: null, // Эта кость является корневой
        },
        {
          id: 1, // ID второй кости
          length: 3.57,
          deviceId: 1,
          axisMapping: {
            x: "gx",
            y: "gy",
            z: "gz",
          },
          initialPosition: { x: 0, y: -3.5, z: 0 }, // Начальное положение кости
          color: 0x00ff00, // Цвет кости (зеленый)
          parentBone: 0, // Родительская кость (ID: 0)
        },
        {
          id: 2, // ID третьей кости
          length: 1,
          deviceId: 2,
          axisMapping: {
            x: "gx",
            y: "gy",
            z: "gz",
          },
          initialPosition: { x: 0, y: -3.57, z: 0 }, // Начальное положение кости
          color: 0x0000ff, // Цвет кости (синий)
          parentBone: 1, // Родительская кость (ID: 1)
        },
      ];

      // Создаем кости
      const bones = [];
      bonesConfig.forEach((boneConfig) => {
        const bone = new THREE.Bone();
        bone.position.set(
          boneConfig.initialPosition.x,
          boneConfig.initialPosition.y,
          boneConfig.initialPosition.z
        );
        bones[boneConfig.id] = bone;
      });

      // Связываем кости в иерархию на основе parentBone
      bonesConfig.forEach((boneConfig) => {
        if (boneConfig.parentBone !== null) {
          const parentBone = bones[boneConfig.parentBone];
          const childBone = bones[boneConfig.id];
          parentBone.add(childBone);
        }
      });

      // Создаем скелет
      const skeleton = new THREE.Skeleton(bones);

      // Создаем визуальное представление костей и суставов
      const boneMeshes = [];
      const jointMeshes = [];

      bonesConfig.forEach((boneConfig, index) => {
        const boneLength = boneConfig.length;

        // Создаем цилиндр для кости
        const boneGeometry = new THREE.CylinderGeometry(
          0.1,
          0.1,
          boneLength,
          8
        );
        boneGeometry.translate(0, -boneLength / 2, 0); // Смещаем геометрию к началу кости

        const boneMaterial = new THREE.MeshBasicMaterial({
          color: boneConfig.color,
        });
        const boneMesh = new THREE.Mesh(boneGeometry, boneMaterial);
        boneMeshes.push(boneMesh);

        // Создаем сферу для сустава
        const jointGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const jointMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const jointMesh = new THREE.Mesh(jointGeometry, jointMaterial);
        jointMeshes.push(jointMesh);

        // Добавляем кость и сустав в сцену
        scene.add(boneMesh);
        scene.add(jointMesh);
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update(); // Update OrbitControls
        renderer.render(scene, camera);
      }
      animate();

      // Function to fetch data periodically
      async function fetchData() {
        try {
          const response = await fetch("/data");
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();

          // Update bone orientations based on gyroscope data
          bonesConfig.forEach((boneConfig, index) => {
            const deviceData = data[`d${boneConfig.deviceId}`];
            if (deviceData && bones[index]) {
              const bone = bones[index];

              // Map device vectors to bone axes
              const rotationX = deviceData[boneConfig.axisMapping.x];
              const rotationY = deviceData[boneConfig.axisMapping.y];
              const rotationZ = deviceData[boneConfig.axisMapping.z];

              // Apply rotation to the bone
              bone.rotation.set(rotationX, rotationY, rotationZ);
            }
          });

          // Update positions and orientations of visual elements
          bones.forEach((bone, index) => {
            const boneMesh = boneMeshes[index];
            const jointMesh = jointMeshes[index];

            // Update bone mesh position and orientation
            boneMesh.position.copy(bone.getWorldPosition(new THREE.Vector3()));
            boneMesh.quaternion.copy(
              bone.getWorldQuaternion(new THREE.Quaternion())
            );

            // Update joint mesh position
            jointMesh.position.copy(bone.getWorldPosition(new THREE.Vector3()));
          });
        } catch (error) {
          console.error("Error fetching data:", error);
        }
      }

      // Start or stop streaming
      function toggleStream() {
        const button = document.getElementById("streamButton");
        if (!isStreaming) {
          fetch("/start").then(() => {
            intervalId = setInterval(fetchData, 100); // Fetch data every 100ms
            isStreaming = true;
            button.textContent = "Stop Streaming";
          });
        } else {
          fetch("/stop").then(() => {
            clearInterval(intervalId);
            isStreaming = false;
            button.textContent = "Start Streaming";
          });
        }
      }

      // Attach event listener to the button
      document
        .getElementById("streamButton")
        .addEventListener("click", toggleStream);

      // Добавляем SkeletonHelper для визуализации скелета
      const skeletonHelper = new THREE.SkeletonHelper(bones[0]);
      scene.add(skeletonHelper);
    </script>
  </body>
</html>
