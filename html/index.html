<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SENSORIO</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header>
      <img src="logo.svg" alt="Logo" class="logo" />
      <h1>SENSORIO</h1>
    </header>
    <main>
      <button id="streamButton">Start Streaming</button>
      <div id="canvas-container"></div>
    </main>
    <script type="importmap">
      {
        "imports": {
          "three": "/three.module.min.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "/OrbitControls.min.js";

      let isStreaming = false;
      let intervalId;

      // Three.js setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document
        .getElementById("canvas-container")
        .appendChild(renderer.domElement);

      // Add OrbitControls for camera rotation
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // Smooth movement
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 5;
      controls.maxDistance = 20;
      controls.target.set(0, 0, 0); // Center of the skeleton

      camera.position.set(0, 0, 10); // Position the camera to see the entire skeleton

      // Описание костей
      const bonesConfig = [
        {
          id: 0, // ID первой кости
          size: { length: 1, width: 0.1, height: 0.1 }, // Размеры кости
          deviceId: 0, // Номер устройства, привязанного к этой кости
          axisMapping: {
            x: "gx", // Вектор gx устройства проецируется на ось X кости
            y: "gy", // Вектор gy устройства проецируется на ось Y кости
            z: "gz", // Вектор gz устройства проецируется на ось Z кости
          },
        },
        {
          id: 1, // ID второй кости
          size: { length: 1, width: 0.1, height: 0.1 },
          deviceId: 1,
          axisMapping: {
            x: "gx",
            y: "gy",
            z: "gz",
          },
        },
        {
          id: 2, // ID третьей кости
          size: { length: 1, width: 0.1, height: 0.1 },
          deviceId: 2,
          axisMapping: {
            x: "gx",
            y: "gy",
            z: "gz",
          },
        },
      ];

      // Описание связей между костями
      const boneConnections = [
        {
          parentBoneId: 0, // Первая кость
          childBoneId: 1, // Вторая кость
          jointPosition: new THREE.Vector3(1, 0, 0), // Точка соединения относительно первой кости
        },
        {
          parentBoneId: 1, // Вторая кость
          childBoneId: 2, // Третья кость
          jointPosition: new THREE.Vector3(1, 0, 0), // Точка соединения относительно второй кости
        },
      ];

      // Create bones based on configuration
      const bones = [];
      bonesConfig.forEach((boneConfig) => {
        const geometry = new THREE.BoxGeometry(
          boneConfig.size.length,
          boneConfig.size.width,
          boneConfig.size.height
        );

        // Translate geometry so that the start of the bone is at the origin
        geometry.translate(-boneConfig.size.length / 2, 0, 0);

        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const bone = new THREE.Mesh(geometry, material);
        bone.position.set(0, 0, 0); // Initial position
        scene.add(bone);
        bones[boneConfig.id] = bone;
      });

      // Link bones together based on connections
      boneConnections.forEach((connection) => {
        const parentBone = bones[connection.parentBoneId];
        const childBone = bones[connection.childBoneId];

        // Set the child bone's position relative to the parent bone
        childBone.position.copy(
          parentBone.localToWorld(connection.jointPosition)
        );
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update(); // Update OrbitControls
        renderer.render(scene, camera);
      }
      animate();

      // Function to fetch data periodically
      async function fetchData() {
        try {
          const response = await fetch("/data");
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();

          // Update bone orientations based on gyroscope data
          bonesConfig.forEach((boneConfig) => {
            const deviceData = data[`d${boneConfig.deviceId}`];
            if (deviceData) {
              const bone = bones[boneConfig.id];

              // Map device vectors to bone axes
              const rotationX = deviceData[boneConfig.axisMapping.x];
              const rotationY = deviceData[boneConfig.axisMapping.y];
              const rotationZ = deviceData[boneConfig.axisMapping.z];

              // Apply rotation to the bone
              bone.rotation.set(rotationX, rotationY, rotationZ);
            }
          });

          // Update positions of connected bones
          boneConnections.forEach((connection) => {
            const parentBone = bones[connection.parentBoneId];
            const childBone = bones[connection.childBoneId];

            // Update the child bone's position based on the parent bone's orientation
            const nextBonePosition = parentBone.localToWorld(
              connection.jointPosition.clone()
            );
            childBone.position.copy(nextBonePosition);
          });
        } catch (error) {
          console.error("Error fetching data:", error);
        }
      }

      // Start or stop streaming
      function toggleStream() {
        const button = document.getElementById("streamButton");
        if (!isStreaming) {
          fetch("/start").then(() => {
            intervalId = setInterval(fetchData, 100); // Fetch data every 100ms
            isStreaming = true;
            button.textContent = "Stop Streaming";
          });
        } else {
          fetch("/stop").then(() => {
            clearInterval(intervalId);
            isStreaming = false;
            button.textContent = "Start Streaming";
          });
        }
      }

      // Attach event listener to the button
      document
        .getElementById("streamButton")
        .addEventListener("click", toggleStream);
    </script>
  </body>
</html>
